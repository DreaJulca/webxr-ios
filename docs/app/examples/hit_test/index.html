
  <html>
	<head>
		<title>Hit test example</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body, html {
				padding: 0;
				margin: 0;
				overflow: hidden;
				position: fixed;
				width: 100%;
				height: 100vh;
				-webkit-user-select: none;
				user-select: none;
			}
			#target {
				width: 100%;
				height: 100%;
				position: absolute;
			}
			.common-message {
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				font-size: 20px;
			}
		</style>

		<script src="../libs/three.min.js"></script>
		<script type="module" src="../../polyfill/XRPolyfill.js"></script>
		<script nomodule src="../../dist/webxr-polyfill.js"></script>
		<script src="../common.js"></script>
	</head>
	<body>
		<div id="target" />
		<script>
			/*
			HitTestExample shows how to find surfaces or other features and place content relative to them.

			In a production application, you would not create a separate anchor for every user action because
			your application would quickly slow down tracking so many anchors. Instead, find an anchor
			for groups of content that are positioned relative to some surface or other feature.
			*/
			class HitTestExample extends XRExampleBase {
				constructor(domElement){
					super(domElement, false)
					this._tapEventData = null // Will be filled in on touch start and used in updateStageGroup

					this.anchoredNodes = [] // { XRAnchorOffset, Three.js Object3D }

					// A message at the bottom of the screen that shows whether a surface has been found
					this._messageEl = document.createElement('div')
					this.el.appendChild(this._messageEl)
					this._messageEl.style.position = 'absolute'
					this._messageEl.style.bottom = '10px'
					this._messageEl.style.left = '10px'
					this._messageEl.style.color = 'white'
					this._messageEl.style['font-size'] = '16px'

					this.el.addEventListener('touchstart', this._onTouchStart.bind(this), false)
				}

				// Called during construction to allow the app to populate this.stageGroup (a THREE.Group)
				initializeStageGroup(){
					// Add a box at the stage origin to show where the stage group is located
					let box = new THREE.Mesh(
						new THREE.BoxBufferGeometry(0.1, 0.1, 0.1),
						new THREE.MeshPhongMaterial({ color: '#DDFFDD' })
					)
					box.position.set(0, 0, 0)
					this.stageGroup.add(box)

					// Add a box one meter in front of stage origin to show the direction of the Z axis
					box = new THREE.Mesh(
						new THREE.BoxBufferGeometry(0.1, 0.1, 0.1),
						new THREE.MeshPhongMaterial({ color: '#FF0000' })
					)
					box.position.set(0, 0, -1)
					this.stageGroup.add(box)

					// Add a few lights
					this.stageGroup.add(new THREE.AmbientLight('#FFF', 0.2))
					let directionalLight = new THREE.DirectionalLight('#FFF', 0.6)
					directionalLight.position.set(0, 10, 0)
					this.stageGroup.add(directionalLight)
				}

				// Called once per frame, before render, to give the app a chance to update this.stageGroup (a THREE.Group)
				updateStageGroup(frame, stageCoordinateSystem, stagePose){
					// If we have tap data, attempt a hit test for a surface
					if(this._tapEventData !== null){
						const x = this._tapEventData[0]
						const y = this._tapEventData[1]
						this._tapEventData = null
						// Attempt a hit test using the normalized screen coordinates
						frame.findAnchor(x, y).then(anchorOffset => {
							if(anchorOffset === null){
								this._messageEl.innerHTML = 'miss'
							} else {
								const anchor = frame.getAnchor(anchorOffset.anchorUID)
								this._messageEl.innerHTML = 'hit: ' + anchor.coordinates.position.join(', ')

								// Save the XRAnchorOffset and the node so that we can update the node's position based off of the anchor
								let anchorInfo = {
									anchorOffset: anchorOffset,
									node: this._createSceneGraphNode()
								}
								this.anchoredNodes.push(anchorInfo)

								// Add a block to the scene to indicate the position of the XRAnchorOffset
								// Its position will be updated below along with the other anchored nodes
								this.stageGroup.add(anchorInfo.node)
							}
						}).catch(err => {
							console.error('Error in hit test', err)
						})
					}

					// Update anchored node positions in the scene graph using updated anchor positions
					for(let anchoredNode of this.anchoredNodes){
						const anchor = frame.getAnchor(anchoredNode.anchorOffset.anchorUID)
						if(anchor === null){
							throttledConsoleLog('Unknown anchor uid', anchoredNode.anchorOffset.anchorUID)
						} else {
							anchoredNode.node.matrixAutoUpdate = false
							let offsetCoordinates = anchoredNode.anchorOffset.getTransformedCoordinates(anchor)
							if(offsetCoordinates.coordinateSystem.type === XRCoordinateSystem.STAGE){
								anchoredNode.node.matrix.fromArray(offsetCoordinates.poseMatrix)
							} else {
								anchoredNode.node.matrix.fromArray(offsetCoordinates.getTransformedCoordinates(stageCoordinateSystem).poseMatrix)
							}
							anchoredNode.node.updateMatrixWorld(true)
						}
					}
				}

				// Save screen taps as normalized coordinates for use in this.updateStageGroup
				_onTouchStart(ev){
					if (!ev.touches || ev.touches.length === 0) {
						console.error('No touches on touch event', ev)
						return
					}
					this._tapEventData = [
						ev.touches[0].pageX / window.innerWidth,
						ev.touches[0].pageY / window.innerHeight
					]
					console.log('touch', this._tapEventData)
				}

				// Creates a box used to indicate the location of an anchor offset
				_createSceneGraphNode(){
					let geometry = new THREE.BoxBufferGeometry(0.1, 0.1, 0.1)
					let material = new THREE.MeshPhongMaterial({ color: '#99FF99' })
					return new THREE.Mesh(geometry, material)
				}
			}


			window.addEventListener('DOMContentLoaded', () => {
				setTimeout(() => {
					try {
						window.pageApp = new HitTestExample(document.getElementById('target'))
					} catch(e) {
						console.error('page error', e)
					}
				}, 1000)
			})
		</script>
	</body>
</html>
